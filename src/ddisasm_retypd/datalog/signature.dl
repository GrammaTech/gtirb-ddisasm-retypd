//////////////////////////////////////////////////////////////////////////////
// Relations for determining the arguments of a function

// Determine whether a register can reach a certain instruction without having
// a write to it. This doesn't necessarily mean on *all* paths it is unwritten
// but there is *at least one* path where it is unwritten.
.decl reaches_without_write(ea:address, reg:register)
reaches_without_write(EA, Reg) :-
    block_instruction(EA, _),
    track_register(_, Reg),
    (
        !register_access(EA, "Writes", Reg)
        ;
        register_access(EA, "Writes", Reg),
        register_access(EA, "Reads", Reg)
    ),
    (
        next_instruction(PrevEA, EA),
        reaches_without_write(PrevEA, Reg)
        ;
        function_inference.function_entry_name(EA, _)
    ).


// Determine whether there is a use-def chain between caller/callee pairs
//     EA_def: mov Reg, ...
//             call Callee
//     ..
//     Caller: mov ..., Reg
.decl writes_argument_before_call(caller:symbol, ea_def:address, reg:register, callee:symbol, index:unsigned)
.output writes_argument_before_call
writes_argument_before_call(Caller, EA_def, Reg, Callee, Index) :-
    // An register parameter is written to a call..
    register_access(EA_def, "Writes", Reg),
    param_register(_, Reg, Index),
    !reg_def_use.def_use(EA_def, Reg, _),

    // ... in function Caller ...
    block_instruction(EA_def, DefBlock),
    function_inference.in_function(DefBlock, Caller_addr),
    function_inference.function_entry_name(Caller_addr, Caller),

    // ... that is a CALL operation to Callee
    cfg_edge(DefBlock, UseBlock, _, _, "call"),
    function_inference.in_function(UseBlock, Callee_addr),
    function_inference.function_entry_name(Callee_addr, Callee).

// Determines whether a parameter is used but never defined
.decl reads_unwritten_argument(func:symbol, ea_def:address, reg:register, index:unsigned)
.output reads_unwritten_argument
reads_unwritten_argument(Func, EA_use, Reg, Index) :-
    explicit_reads_register(EA_use, Reg),
    reaches_without_write(EA_use, Reg),
    param_register(_, Reg, Index),

    block_instruction(EA_use, UseBlock),
    function_inference.in_function(UseBlock, Func_addr),
    function_inference.function_entry_name(Func_addr, Func).

// Passes an implicit argument from a callee
.decl writes_implicit_argument(writer:symbol, ea_def:unsigned, caller:symbol, callee:symbol, ea_use:unsigned, index:unsigned)
.output writes_implicit_argument
writes_implicit_argument(Writer, EA_def, Caller, Callee, EA_use, Index) :-
    call_reaches_with(Writer, Caller, Callee),
    reads_unwritten_argument(Callee, EA_use, _, Index),
    !writes_argument_before_call(Caller, _, Reg, Caller, Index),
    writes_argument_before_call(Writer, EA_def, Reg, Caller, Index).

//////////////////////////////////////////////////////////////////////////////
// Relations for determining the return value of a function

// Determine whether or not a function has a return value directly written in
// the function, and is subsequentially read:
//     EA: mov EAX, 1
//         ret
.decl writes_read_return_value(func:symbol, def_ea:address, use_ea:address)
.output writes_read_return_value
writes_read_return_value(Func, EA_def, EA_use) :-
    // A return value is written...
    reg_def_use.def_use(EA_def, Reg, EA_use),
    return_register(_, Reg),

    // ...defined in function Func...
    block_instruction(EA_def, DefBlock),
    function_inference.in_function(DefBlock, Func_addr),
    function_inference.function_entry_name(Func_addr, Func),

    // ...used in function UseFunc...
    block_instruction(EA_use, UseBlock),
    function_inference.in_function(UseBlock, UseFunc_addr),

    // ...which are different functions.
    UseFunc_addr != Func_addr.


// Determine whether or not a function has a return value that is implicitly
// passed through a callee of the function, i.e.:
//     ReturnedFunc:
//     EA_ret: mov Reg, ...
//             ret
//     Func:
//             call ReturnedFunc
//             ret
.decl may_pass_implicit_return_value(func:symbol, returned_func:symbol, returned_ea:address)
.output may_pass_implicit_return_value
may_pass_implicit_return_value(Func, ReturnedFunc, EA_ret) :-
    // Get a function without a return value...
    function_inference.function_entry_name(_, Func),
    !writes_read_return_value(Func, _, _),
    !writes_unread_return_value(Func, _),

    // ... that is called by another function with a return value from
    // ReturnedFunc (itself or another fallthrough)...
    call_graph(Func, DestFunc),
    (
        writes_read_return_value(DestFunc, EA_ret, _),
        ReturnedFunc=DestFunc
        ;
        writes_unread_return_value(DestFunc, EA_ret),
        ReturnedFunc=DestFunc
        ;
        may_pass_implicit_return_value(DestFunc, ReturnedFunc, EA_ret)
    ).

// Determine if theres an instruction which has a use of a register that may be
// implicitly passed via function call
// TODO: This currently assumes that the implicitly passed value is accessed
// directly after
.decl reads_implicit_return_value(func:symbol, called_func:symbol, EA_use:address, reg:register)
.output reads_implicit_return_value
reads_implicit_return_value(Func, CalledFunc, EA_use, Reg) :-
    // Find a call from Func to CalledFunc which returns to Func after that
    // call...
    cfg_edge(BlockFrom, BlockTo, _, _, "call"),
    cfg_edge(BlockFrom, BlockFallthrough, _, _, "fallthrough"),
    function_inference.in_function(BlockFrom, Func_addr),
    function_inference.function_entry_name(Func_addr, Func),
    function_inference.in_function(BlockTo, CalledFunc_addr),
    function_inference.function_entry_name(CalledFunc_addr, CalledFunc),

    // ... if CalledFunc may implicitly return a value in Reg ...
    may_pass_implicit_return_value(Func, CalledFunc, EA_ret),
    explicit_writes_register(EA_ret, Reg),

    // ... and if we assume that a read of the implicitly passed value would be
    // in the block directly after this call, find a read of that value which
    // wasn't defined within that succeeding block ...
    block_instruction(BlockFallthrough, EA_fallthrough),
    register_access(EA_fallthrough, "Reads", Reg),

    (
        // ... either there is no def-use on that read of Reg ...
        !reg_def_use.def_use(_, Reg, EA_fallthrough)
        ;
        // ... or there is one thats not in this block (and therefore since we
        // assume that this is jumped to from the call which we assume writes
        // Reg, that def-use would be invalid) ...
        reg_def_use.def_use(EA_spurious_from, Reg, EA_fallthrough),
        !block_instruction(EA_fallthrough, EA_spurious_from)
    ),

    // ... then the access of Reg at EA_fallthrough is actually a read of the
    // implicitly passed return value of CalledFunc.
    EA_use=EA_fallthrough.


// Determine whether or not a function writes to the register that is used for
// return values without reading it, this is likely a return value
.decl writes_unread_return_value(func:symbol, def_ea:address)
.output writes_unread_return_value
writes_unread_return_value(Func, EA_def) :-
    return_register(_, Reg),
    explicit_writes_register(EA_def, Reg),
    reg_def_use.reaches(EA_def, Reg, EA_to),
    return(EA_to),

    block_instruction(EA_def, Block),
    function_inference.in_function(Block, Func_addr),
    function_inference.function_entry_name(Func_addr, Func).

// Determine whether or not a function has a return value in a register, and
// report which instructions are writing those return values.
.decl writes_return_value(func:symbol, def_ea:address)
.output writes_return_value
writes_return_value(Func, EA_def) :-
    writes_read_return_value(Func, EA_def, _)
    ;
    may_pass_implicit_return_value(Func, _, EA_def),
    reads_implicit_return_value(_, Func, _, _)
    ;
    writes_unread_return_value(Func, EA_def).

// Determine whether a function reads a return value directly returned by a
// called function
.decl reads_direct_return(use_func:symbol, def_func:symbol, use_ea:address)
.output reads_direct_return
reads_direct_return(UseFunc, DefFunc, EA_use) :-
    writes_read_return_value(DefFunc, _, EA_use),
    block_instruction(EA_use, Block),
    function_inference.in_function(Block, UseFunc_addr),
    function_inference.function_entry_name(UseFunc_addr, UseFunc).

// Detrmine whether a function reads a return value passed by a given function
.decl reads_return_value(use_func:symbol, def_func:symbol, use_ea:address)
.output reads_return_value
reads_return_value(UseFunc, DefFunc, EA_use) :-
    reads_implicit_return_value(UseFunc, DefFunc, EA_use, _)
    ;
    reads_direct_return(UseFunc, DefFunc, EA_use).
