//////////////////////////////////////////////////////////////////////////////
// Relations imported from ddisasm's exported facts

.decl binary_format(Format:symbol)
.input binary_format

.decl binary_isa(isa:symbol)
.input binary_isa

.decl op_indirect(code:operand_code, reg1:register, reg2:register, reg3:register,
        multiplier:number, offset:number, size_value:unsigned)
.input op_indirect

.decl instruction_get_operation(ea:address, operation:symbol)
.input  instruction_get_operation

.decl instruction_get_op(ea:address, index:operand_index, operator:operand_code)
.input instruction_get_op

.decl instruction_get_src_op(ea:address, Index:operand_index, op:operand_code)
.input instruction_get_src_op

.decl instruction_get_dest_op(ea:address, index:number, op:operand_code)
.input instruction_get_dest_op


.decl instruction(ea:address, size:unsigned, prefix:symbol, opcode:symbol,
          op1:operand_code, op2:operand_code, op3:operand_code, op4:operand_code,
          immOffset:unsigned,displacementOffset:unsigned)
.input instruction

.decl op_regdirect_contains_reg(op:operand_code, reg:register)
.input op_regdirect_contains_reg

.decl op_register_bitfield(code:operand_code, register_name:register)
.input op_register_bitfield

.decl op_immediate(code:operand_code, offset:number)
.input op_immediate

.decl op_regdirect(code:operand_code,register_name:register)
.input op_regdirect

.decl code_in_block(ea:address, block:address)
.input code_in_block

.decl function_symbol(ea:address, name:symbol)
.input function_symbol

.decl def_used(ea_def:address, reg:register, ea_used:address, index_used:operand_index)
.input def_used

.decl cfg_edge(src:address, dest:address, conditional:symbol, indirect:symbol, type:symbol)
.input cfg_edge

.decl reg_call(src:address, reg:register)
.input reg_call

.decl data_access(EA:address, Op_index:operand_index, RegSegment:register, RegBase:register, RegIndex:register, Mult:number, Offset:number, Size:unsigned)
.input data_access

.decl reg_stored_in_stack(EA:address, Reg:register, StackPos:number, StackFrameDefinedAt: address)
.input reg_stored_in_stack

.decl reg_loaded_from_stack(EA:address, Reg:register, Base:register, StackPos:number, StackFrameDefinedAt: address)
.input reg_loaded_from_stack

.decl local_next(ea:address, ea_next:address)
.input local_next

.decl block_next(ea:address, block:address)
.input block_next

.comp abs_arch {
    .decl pointer_size(N: unsigned)
    .input pointer_size

    .decl mov(EA:address)
    .input mov

    .decl read_only_operation(Operation:symbol)
    .input read_only_operation

    .decl pc_register(reg:register)
    .input pc_register

    .decl frame_pointer(reg:register)
    .input frame_pointer

    .decl stack_pointer(reg:register)
    .input stack_pointer

    .decl arithmetic_operation(Operation:symbol)
    .input arithmetic_operation

    .decl logic_operation(Operation:symbol)
    .input logic_operation

    .decl cmp_operation(Operation:symbol)
    .input cmp_operation

    .decl conditional(EA:address)
    .input conditional

    .decl jump(EA:address)
    .input jump

    .decl return(src:address)
    .input return

    .decl track_register(reg1:register,reg2:register)
    .input track_register

    .decl move_operation(Operation:symbol)
    .input move_operation

    .decl reg_arithmetic_operation(EA:address,Dst:register,Src:register,Mult:number,Offset:number)
    .input reg_arithmetic_operation
}

.init arch = abs_arch

.comp abs_function_inference {
    .decl in_function(Block:address, Function:address)
    .input in_function
}

.init function_inference = abs_function_inference

.decl symbolic_operand(ea:address, index:operand_index, value:address, type:symbol)
.input symbolic_operand

.decl op_indirect_contains_reg(op:operand_code,reg:register)
.input op_indirect_contains_reg

.decl value_reg(EA:address,Reg:register,
                EA_reg1:address,Reg1:register,Multiplier:number,Offset:number,steps:number)
.input value_reg
